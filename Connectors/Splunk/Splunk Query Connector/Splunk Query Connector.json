{
    "isUpdateAvailable": false,
    "isCustom": false,
    "isEnabled": false,
    "isRemoteConnector": false,
    "environment": "Default Environment",
    "integration": "Splunk",
    "identifier": "Splunk Query Connector_39149e0d-98dc-4f46-b95a-218882b437d7",
    "connectorDefinitionName": "Splunk Query Connector",
    "displayName": "Splunk Query Connector",
    "description": "The connector sends queries that are a part of the whitelist, retrieves results and builds a case based on the results.",
    "runIntervalInSeconds": 10,
    "resultDataType": 0,
    "version": "1",
    "pythonVersion": 3,
    "isAllowlistSupported": false,
    "params": [
        {
            "connectorIdentifier": null,
            "paramName": "Script Timeout (Seconds)",
            "paramValue": "60",
            "description": "The timeout limit (in seconds) for the python process running current script",
            "type": 2,
            "mode": 0,
            "isDisplayed": true,
            "isMandatory": true,
            "isAdvanced": true,
            "id": 0,
            "creationTimeUnixTimeInMs": 0,
            "modificationTimeUnixTimeInMs": 0
        },
        {
            "connectorIdentifier": null,
            "paramName": "Api Root",
            "paramValue": "https://lab:8089",
            "description": "API root of the Splunk instance.",
            "type": 2,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": true,
            "isAdvanced": false,
            "id": 0,
            "creationTimeUnixTimeInMs": 0,
            "modificationTimeUnixTimeInMs": 0
        },
        {
            "connectorIdentifier": null,
            "paramName": "Username",
            "paramValue": "admin",
            "description": "Username of the Splunk account.",
            "type": 2,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": false,
            "isAdvanced": false,
            "id": 0,
            "creationTimeUnixTimeInMs": 0,
            "modificationTimeUnixTimeInMs": 0
        },
        {
            "connectorIdentifier": null,
            "paramName": "Password",
            "paramValue": "***************",
            "description": "Password of the Splunk account.",
            "type": 3,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": false,
            "isAdvanced": false,
            "id": 0,
            "creationTimeUnixTimeInMs": 0,
            "modificationTimeUnixTimeInMs": 0
        },
        {
            "connectorIdentifier": null,
            "paramName": "API Token",
            "paramValue": "",
            "description": "Splunk API Token. API token has priority over other authentication methods, when this field is not empty.",
            "type": 3,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": false,
            "isAdvanced": false,
            "id": 0,
            "creationTimeUnixTimeInMs": 0,
            "modificationTimeUnixTimeInMs": 0
        },
        {
            "connectorIdentifier": null,
            "paramName": "Verify SSL",
            "paramValue": "false",
            "description": "Whether to verify ssl certificate on connection or not",
            "type": 0,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": false,
            "isAdvanced": false,
            "id": 0,
            "creationTimeUnixTimeInMs": 0,
            "modificationTimeUnixTimeInMs": 0
        },
        {
            "connectorIdentifier": null,
            "paramName": "Environment Field Name",
            "paramValue": "",
            "description": "Field which represent the environment in the event data.",
            "type": 2,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": false,
            "isAdvanced": false,
            "id": 0,
            "creationTimeUnixTimeInMs": 0,
            "modificationTimeUnixTimeInMs": 0
        },
        {
            "connectorIdentifier": null,
            "paramName": "Rule Generator Field",
            "paramValue": "Rule",
            "description": "Field that represents the rule generator field.",
            "type": 2,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": true,
            "isAdvanced": false,
            "id": 0,
            "creationTimeUnixTimeInMs": 0,
            "modificationTimeUnixTimeInMs": 0
        },
        {
            "connectorIdentifier": null,
            "paramName": "Alert Name Field Name",
            "paramValue": "Alert",
            "description": "Field which represent the alert name.",
            "type": 2,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": true,
            "isAdvanced": false,
            "id": 0,
            "creationTimeUnixTimeInMs": 0,
            "modificationTimeUnixTimeInMs": 0
        },
        {
            "connectorIdentifier": null,
            "paramName": "Events Count Limit Per Query",
            "paramValue": "10",
            "description": "Max amount of events to fetch per query, e.g: 10",
            "type": 2,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": false,
            "isAdvanced": false,
            "id": 0,
            "creationTimeUnixTimeInMs": 0,
            "modificationTimeUnixTimeInMs": 0
        },
        {
            "connectorIdentifier": null,
            "paramName": "Max Days Backwards",
            "paramValue": "1",
            "description": "Number of days before the first connector iteration to retrieve events from. This parameter applies to the initial connector iteration after you enable the connector for the first time, or used as a fallback value in cases where connector's last run timestamp expires.",
            "type": 2,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": false,
            "isAdvanced": false,
            "id": 0,
            "creationTimeUnixTimeInMs": 0,
            "modificationTimeUnixTimeInMs": 0
        },
        {
            "connectorIdentifier": null,
            "paramName": "Aggregate Events Query",
            "paramValue": "false",
            "description": "If enabled, the connector will combine all events under one alert.",
            "type": 0,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": false,
            "isAdvanced": false,
            "id": 0,
            "creationTimeUnixTimeInMs": 0,
            "modificationTimeUnixTimeInMs": 0
        },
        {
            "connectorIdentifier": null,
            "paramName": "Proxy Server Address",
            "paramValue": "",
            "description": "The address of the proxy server to use.",
            "type": 2,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": false,
            "isAdvanced": true,
            "id": 0,
            "creationTimeUnixTimeInMs": 0,
            "modificationTimeUnixTimeInMs": 0
        },
        {
            "connectorIdentifier": null,
            "paramName": "Proxy Username",
            "paramValue": "",
            "description": "The proxy username to authenticate with.",
            "type": 2,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": false,
            "isAdvanced": true,
            "id": 0,
            "creationTimeUnixTimeInMs": 0,
            "modificationTimeUnixTimeInMs": 0
        },
        {
            "connectorIdentifier": null,
            "paramName": "Proxy Password",
            "paramValue": "",
            "description": "The proxy password to authenticate with.",
            "type": 3,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": false,
            "isAdvanced": true,
            "id": 0,
            "creationTimeUnixTimeInMs": 0,
            "modificationTimeUnixTimeInMs": 0
        },
        {
            "connectorIdentifier": null,
            "paramName": "CA Certificate File",
            "paramValue": "",
            "description": "CA Certificate File",
            "type": 2,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": false,
            "isAdvanced": true,
            "id": 0,
            "creationTimeUnixTimeInMs": 0,
            "modificationTimeUnixTimeInMs": 0
        },
        {
            "connectorIdentifier": null,
            "paramName": "Environment Regex Pattern",
            "paramValue": ".*",
            "description": "A regex pattern to run on the value found in the 'Environment Field Name' field. Default is .* to catch all and return the value unchanged. Used to allow the user to manipulate the environment field via regex logic. If the regex pattern is null or empty, or the environment value is null, the final environment result is the default environment.",
            "type": 2,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": false,
            "isAdvanced": true,
            "id": 0,
            "creationTimeUnixTimeInMs": 0,
            "modificationTimeUnixTimeInMs": 0
        }
    ],
    "allowList": [],
    "integrationVersion": 59.0,
    "isScriptConnector": true,
    "script": "import sys\nimport uuid\nfrom itertools import chain\n\nfrom EnvironmentCommon import GetEnvironmentCommonFactory\nfrom SiemplifyConnectors import SiemplifyConnectorExecution\nfrom SiemplifyConnectorsDataModel import AlertInfo\nfrom SiemplifyUtils import output_handler, unix_now\nfrom SplunkManager import SplunkManager\nfrom TIPCommon.extraction import extract_connector_param\nfrom TIPCommon.smp_io import read_ids, write_ids\nfrom TIPCommon.utils import is_overflowed\nfrom UtilsManager import (\n    clean_duplicated_keys,\n    get_last_success_time_for_queries,\n    get_query_identifier,\n    is_approaching_timeout,\n    save_query_timestamp,\n)\nfrom constants import DEFAULT_DEVICE_VENDOR, QUERY_CONNECTOR_SCRIPT_NAME\n\n\nconnector_starting_time = unix_now()\n\n\ndef get_alert_info(\n    events,\n    device_product_field_name,\n    rule_generator_field_name,\n    query,\n    alert_name_field_name,\n    environment_common,\n):\n    alert_info = AlertInfo()\n\n    event_json = list(map(clean_duplicated_keys, [event.to_flat() for event in events]))\n    alert_info.start_time = events[0].timestamp\n    alert_info.end_time = events[-1].timestamp\n    alert_info.rule_generator = event_json[0].get(rule_generator_field_name, query)\n    alert_info.device_product = event_json[0].get(\n        device_product_field_name, \"Splunk Query\"\n    )\n    alert_info.name = event_json[0].get(alert_name_field_name, f\"Query: {query}\")\n    alert_info.events = event_json\n\n    alert_info.environment = environment_common.get_environment(events[0].to_flat())\n    alert_info.device_vendor = DEFAULT_DEVICE_VENDOR\n    alert_info.ticket_id = f\"{alert_info.start_time}_{str(uuid.uuid4())}\"\n    alert_info.display_id = alert_info.identifier = alert_info.ticket_id\n    alert_info.extensions = {\"query\": query}\n\n    return alert_info\n\n\ndef split_events_to_lists(events_list, aggregate_events_query):\n    \"\"\"\n    Split event list to events lists list.\n    :param events_list: {list} List of dicts.\n    :param aggregate_events_query: {}\n    :return:\n    \"\"\"\n    if aggregate_events_query:\n        return [events_list] if events_list else []\n\n    return [[event] for event in events_list]\n\n\n@output_handler\ndef main(is_test_run=False):\n    \"\"\"\n    :param is_test_run: run test flow of real flow (timestamp updating is the differencee)\n    :return: -\n    \"\"\"\n    siemplify = SiemplifyConnectorExecution()\n    siemplify.script_name = QUERY_CONNECTOR_SCRIPT_NAME\n    cases, processed_events = [], []\n\n    if is_test_run:\n        siemplify.LOGGER.info(\n            '***** This is an \"IDE Play Button\"\\\\\"Run Connector once\" test run ******'\n        )\n\n    try:\n        server_address = extract_connector_param(siemplify, param_name=\"Api Root\")\n        username = extract_connector_param(siemplify, param_name=\"Username\")\n        password = extract_connector_param(siemplify, param_name=\"Password\")\n        api_token = extract_connector_param(siemplify, param_name=\"API Token\")\n        verify_ssl = extract_connector_param(\n            siemplify, param_name=\"Verify SSL\", default_value=False, input_type=bool\n        )\n        ca_certificate = extract_connector_param(\n            siemplify, param_name=\"CA Certificate File\", print_value=False\n        )\n\n        environment_field_name = extract_connector_param(\n            siemplify, param_name=\"Environment Field Name\"\n        )\n        environment_regex_pattern = extract_connector_param(\n            siemplify, param_name=\"Environment Regex Pattern\"\n        )\n        device_product_field_name = extract_connector_param(\n            siemplify, param_name=\"DeviceProductField\", is_mandatory=True\n        )\n        rule_generator_field_name = extract_connector_param(\n            siemplify, param_name=\"Rule Generator Field\", is_mandatory=True\n        )\n        alert_name_field_name = extract_connector_param(\n            siemplify, param_name=\"Alert Name Field Name\", is_mandatory=True\n        )\n        event_limit = extract_connector_param(\n            siemplify,\n            param_name=\"Events Count Limit Per Query\",\n            input_type=int,\n            default_value=100,\n        )\n        event_limit = 1 if is_test_run else event_limit\n        max_days_backwards = extract_connector_param(\n            siemplify, param_name=\"Max Days Backwards\", input_type=int, default_value=1\n        )\n        aggregate_events_query = extract_connector_param(\n            siemplify,\n            param_name=\"Aggregate Events Query\",\n            default_value=False,\n            is_mandatory=True,\n            input_type=bool,\n        )\n        python_process_timeout = extract_connector_param(\n            siemplify,\n            param_name=\"PythonProcessTimeout\",\n            input_type=int,\n            is_mandatory=True,\n            print_value=True,\n        )\n        queries_whitelist = siemplify.whitelist\n\n        splunk_manager = SplunkManager(\n            server_address=server_address,\n            username=username,\n            password=password,\n            api_token=api_token,\n            ca_certificate=ca_certificate,\n            verify_ssl=verify_ssl,\n            siemplify_logger=siemplify.LOGGER,\n        )\n\n        siemplify.LOGGER.info(\"Reading already existing alerts ids...\")\n        existing_ids = read_ids(siemplify)\n        siemplify.LOGGER.info(f\"Loaded {len(existing_ids)} existing ids\")\n        query_timestamp = get_last_success_time_for_queries(\n            siemplify,\n            queries=queries_whitelist,\n            offset_with_metric={\"days\": max_days_backwards},\n        )\n        query_events = {}\n        force_save_timestamp = {}\n        environment_common = GetEnvironmentCommonFactory.create_environment_manager(\n            siemplify, environment_field_name, environment_regex_pattern\n        )\n\n        for query in queries_whitelist:\n            query_identifier = get_query_identifier(query)\n            try:\n                if is_approaching_timeout(\n                    python_process_timeout, connector_starting_time\n                ):\n                    siemplify.LOGGER.info(\n                        \"Timeout is approaching. Connector will gracefully exit\"\n                    )\n                    break\n\n                siemplify.LOGGER.info(f'\\nQuerying Splunk for \"{query}\"')\n                query_events[query_identifier] = []\n\n                earliest_time = query_timestamp.get(query_identifier)\n                latest_time = min(earliest_time + 86400000, unix_now())\n                events = splunk_manager.get_events_by_query(\n                    query,\n                    earliest_time=earliest_time / 1000,\n                    latest_time=latest_time / 1000,\n                    revers_limit=max(event_limit, 100),\n                )\n\n                siemplify.LOGGER.info(\n                    f\"Found {len(events)} events for query \"\n                    f'\"{query}\" with time range '\n                    f\"{str(earliest_time)} - {str(latest_time)}\"\n                )\n                # exclude existing event ids\n                events = list(\n                    filter(lambda event: event.event_id not in existing_ids, events)\n                )\n                siemplify.LOGGER.info(\n                    \"Events count after removing \"\n                    f\"already processed events: {len(events)}\"\n                )\n                # Apply user limit\n                events = events[:event_limit]\n                if not events:\n                    force_save_timestamp[query_identifier] = latest_time\n\n                # split events into lists.Depends on aggregation.\n\n                for event_list in split_events_to_lists(events, aggregate_events_query):\n                    try:\n                        alert_info = get_alert_info(\n                            events=event_list,\n                            query=query,\n                            device_product_field_name=device_product_field_name,\n                            rule_generator_field_name=rule_generator_field_name,\n                            alert_name_field_name=alert_name_field_name,\n                            environment_common=environment_common,\n                        )\n                        siemplify.LOGGER.info(\n                            \"\\nProcessed events timestamps are \"\n                            f'{\", \".join([str(event.timestamp) for event in event_list])} '\n                            \"with timestamp\"\n                        )\n\n                        query_events[query_identifier].extend(event_list)\n                        # Check if overflowed.\n                        if is_overflowed(siemplify, alert_info, is_test_run):\n                            siemplify.LOGGER.info(\n                                \"{alert_name}-\"\n                                \"{alert_identifier}-\"\n                                \"{environment}-{product} found as overflow alert. \"\n                                \"Skipping. \".format(\n                                    alert_name=alert_info.rule_generator,\n                                    alert_identifier=alert_info.ticket_id,\n                                    environment=alert_info.environment,\n                                    product=alert_info.device_product,\n                                )\n                            )\n                            # If is overflowed we should skip\n                            continue\n\n                        processed_events.append(alert_info)\n                        siemplify.LOGGER.info(\n                            \"\\nCase with display id \"\n                            f'\"{alert_info.display_id}\" was created.'\n                        )\n\n                    except Exception as err:\n                        error_massage = (\n                            f\"\\nError occurred creating case package, Error: {err}\"\n                        )\n                        siemplify.LOGGER.error(error_massage)\n                        siemplify.LOGGER.exception(err)\n                        if is_test_run:\n                            raise\n\n            except Exception as err:\n                error_massage = (\n                    f'\\nError occurred running query \"{query}\", Error: {err}'\n                )\n                siemplify.LOGGER.error(error_massage)\n                siemplify.LOGGER.exception(err)\n                if is_test_run:\n                    raise\n\n        if is_test_run:\n            siemplify.LOGGER.info(\n                f'Maximum event limit({event_limit}) for each query reached! \"test run\"'\n            )\n            siemplify.LOGGER.info(\n                \" ------------ Finish Splunk Query Connector Test ------------ \"\n            )\n        else:\n            save_query_timestamp(\n                siemplify,\n                query_alerts=query_events,\n                force_save_timestamp=force_save_timestamp,\n            )\n            write_ids(\n                siemplify,\n                existing_ids\n                + [\n                    event.event_id\n                    for event in chain.from_iterable(query_events.values())\n                ],\n            )\n            siemplify.LOGGER.info(\n                \" ------------ Connector Finished Iteration ------------ \"\n            )\n\n        siemplify.LOGGER.info(f\"{len(processed_events)} cases created.\")\n        siemplify.return_package(processed_events)\n\n    except Exception as err:\n        error_message = f\"Got exception on main handler. Error: {err}\"\n        siemplify.LOGGER.error(error_message)\n        siemplify.LOGGER.exception(err)\n        if is_test_run:\n            raise\n        siemplify.LOGGER.info(\"\\n\")\n\n\nif __name__ == \"__main__\":\n    is_test = not (len(sys.argv) < 2 or sys.argv[1] == \"True\")\n    main(is_test)\n",
    "documentationLink": "https://cloud.google.com/chronicle/docs/soar/marketplace-integrations/splunk#splunk-connector",
    "deviceProductField": "device_product",
    "eventNameField": "app",
    "connectorStatus": null,
    "isNew": false,
    "agentIdentifier": null
}