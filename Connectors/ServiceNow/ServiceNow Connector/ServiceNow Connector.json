{
    "isUpdateAvailable": false,
    "isCustom": false,
    "isEnabled": false,
    "isRemoteConnector": true,
    "environment": "B",
    "integration": "ServiceNow",
    "identifier": "ServiceNow Connector_c67ac4c7-0180-49c1-babc-bcdde43a6771",
    "connectorDefinitionName": "ServiceNow Connector",
    "displayName": "ServiceNow Connector",
    "description": "Fetching incidents from ServiceNow to Siemplify",
    "runIntervalInSeconds": 10,
    "resultDataType": 0,
    "version": "1",
    "pythonVersion": 3,
    "isAllowlistSupported": false,
    "params": [
        {
            "connectorIdentifier": null,
            "paramName": "Use whitelist as a blacklist",
            "paramValue": "false",
            "description": "If enabled, whitelist will be used as a blacklist.",
            "type": 0,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": false,
            "isAdvanced": false,
            "id": 0,
            "creationTimeUnixTimeInMs": 0,
            "modificationTimeUnixTimeInMs": 0
        },
        {
            "connectorIdentifier": null,
            "paramName": "Script Timeout (Seconds)",
            "paramValue": "60",
            "description": "The timeout limit (in seconds) for the python process running current script",
            "type": 2,
            "mode": 0,
            "isDisplayed": true,
            "isMandatory": true,
            "isAdvanced": true,
            "id": 0,
            "creationTimeUnixTimeInMs": 0,
            "modificationTimeUnixTimeInMs": 0
        },
        {
            "connectorIdentifier": null,
            "paramName": "Rule Generator",
            "paramValue": "",
            "description": "The field name used to determine the rule generator.",
            "type": 2,
            "mode": 0,
            "isDisplayed": true,
            "isMandatory": false,
            "isAdvanced": false,
            "id": 0,
            "creationTimeUnixTimeInMs": 0,
            "modificationTimeUnixTimeInMs": 0
        },
        {
            "connectorIdentifier": null,
            "paramName": "Api Root",
            "paramValue": "https://googlellcdemo3.service-now.com/api/now/v1/",
            "description": "https://{dev-instance}.service-now.com/api/now/v1/",
            "type": 2,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": true,
            "isAdvanced": false,
            "id": 0,
            "creationTimeUnixTimeInMs": 0,
            "modificationTimeUnixTimeInMs": 0
        },
        {
            "connectorIdentifier": null,
            "paramName": "Incident Table",
            "paramValue": "incident",
            "description": "This parameter is defining what API root ServiceNow integration is going to use for actions that revolve around incidents. By default the integration uses the \u201ctable/incident\u201d path. ",
            "type": 2,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": false,
            "isAdvanced": true,
            "id": 0,
            "creationTimeUnixTimeInMs": 0,
            "modificationTimeUnixTimeInMs": 0
        },
        {
            "connectorIdentifier": null,
            "paramName": "Username",
            "paramValue": "admin",
            "description": "Username",
            "type": 2,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": true,
            "isAdvanced": false,
            "id": 0,
            "creationTimeUnixTimeInMs": 0,
            "modificationTimeUnixTimeInMs": 0
        },
        {
            "connectorIdentifier": null,
            "paramName": "Password",
            "paramValue": "***************",
            "description": "Password",
            "type": 3,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": true,
            "isAdvanced": false,
            "id": 0,
            "creationTimeUnixTimeInMs": 0,
            "modificationTimeUnixTimeInMs": 0
        },
        {
            "connectorIdentifier": null,
            "paramName": "Verify SSL",
            "paramValue": "false",
            "description": "If enabled, verify the SSL certificate for the connection to the ServiceNow server is valid.",
            "type": 0,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": false,
            "isAdvanced": false,
            "id": 0,
            "creationTimeUnixTimeInMs": 0,
            "modificationTimeUnixTimeInMs": 0
        },
        {
            "connectorIdentifier": null,
            "paramName": "Client ID",
            "paramValue": "",
            "description": "Client ID of Service Now application. Required for Oauth authentication.",
            "type": 2,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": false,
            "isAdvanced": true,
            "id": 0,
            "creationTimeUnixTimeInMs": 0,
            "modificationTimeUnixTimeInMs": 0
        },
        {
            "connectorIdentifier": null,
            "paramName": "Client Secret",
            "paramValue": "",
            "description": "Client Secret of Service Now application. Required for Oauth authentication.",
            "type": 3,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": false,
            "isAdvanced": true,
            "id": 0,
            "creationTimeUnixTimeInMs": 0,
            "modificationTimeUnixTimeInMs": 0
        },
        {
            "connectorIdentifier": null,
            "paramName": "Refresh Token",
            "paramValue": "",
            "description": "Refresh token for Service Now application. Required for Oauth authentication.",
            "type": 3,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": false,
            "isAdvanced": true,
            "id": 0,
            "creationTimeUnixTimeInMs": 0,
            "modificationTimeUnixTimeInMs": 0
        },
        {
            "connectorIdentifier": null,
            "paramName": "Assignment Group",
            "paramValue": "",
            "description": "Name of the assignment group for which you want to ingest records.",
            "type": 2,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": false,
            "isAdvanced": true,
            "id": 0,
            "creationTimeUnixTimeInMs": 0,
            "modificationTimeUnixTimeInMs": 0
        },
        {
            "connectorIdentifier": null,
            "paramName": "Use Oauth Authentication",
            "paramValue": "false",
            "description": "If enabled, integration will use Oauth authentication. Parameters \u201cClient ID\u201c, \u201cClient Secret\u201c and \u201cRefresh Token\u201c are mandatory.",
            "type": 0,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": false,
            "isAdvanced": true,
            "id": 0,
            "creationTimeUnixTimeInMs": 0,
            "modificationTimeUnixTimeInMs": 0
        },
        {
            "connectorIdentifier": null,
            "paramName": "Days Backwards",
            "paramValue": "5",
            "description": "Fetch incidents from 'x' days backwards. e.g. 3",
            "type": 1,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": false,
            "isAdvanced": false,
            "id": 0,
            "creationTimeUnixTimeInMs": 0,
            "modificationTimeUnixTimeInMs": 0
        },
        {
            "connectorIdentifier": null,
            "paramName": "Max Incidents Per Cycle",
            "paramValue": "10",
            "description": "Fetch max 'x' incidents. e.g. 10",
            "type": 1,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": false,
            "isAdvanced": false,
            "id": 0,
            "creationTimeUnixTimeInMs": 0,
            "modificationTimeUnixTimeInMs": 0
        },
        {
            "connectorIdentifier": null,
            "paramName": "Server Time Zone",
            "paramValue": "UTC",
            "description": "The timezone configured in the server, ex. UTC, Asia/Jerusalem etc.",
            "type": 2,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": false,
            "isAdvanced": true,
            "id": 0,
            "creationTimeUnixTimeInMs": 0,
            "modificationTimeUnixTimeInMs": 0
        },
        {
            "connectorIdentifier": null,
            "paramName": "Environments Whitelist",
            "paramValue": "",
            "description": "The environments (domains) to ingest into Siemplify, comma separated list (env1,env2)",
            "type": 2,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": false,
            "isAdvanced": false,
            "id": 0,
            "creationTimeUnixTimeInMs": 0,
            "modificationTimeUnixTimeInMs": 0
        },
        {
            "connectorIdentifier": null,
            "paramName": "Table Name",
            "paramValue": "",
            "description": "The table to fetch from. e.g. incident",
            "type": 2,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": false,
            "isAdvanced": true,
            "id": 0,
            "creationTimeUnixTimeInMs": 0,
            "modificationTimeUnixTimeInMs": 0
        },
        {
            "connectorIdentifier": null,
            "paramName": "Event Name",
            "paramValue": "",
            "description": "The name of the event in Siemplify. e.g. ServiceNowEvent",
            "type": 2,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": false,
            "isAdvanced": true,
            "id": 0,
            "creationTimeUnixTimeInMs": 0,
            "modificationTimeUnixTimeInMs": 0
        },
        {
            "connectorIdentifier": null,
            "paramName": "Proxy Server Address",
            "paramValue": "",
            "description": "The address of the proxy server to use.",
            "type": 2,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": false,
            "isAdvanced": true,
            "id": 0,
            "creationTimeUnixTimeInMs": 0,
            "modificationTimeUnixTimeInMs": 0
        },
        {
            "connectorIdentifier": null,
            "paramName": "Proxy Username",
            "paramValue": "",
            "description": "The proxy username to authenticate with.",
            "type": 2,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": false,
            "isAdvanced": true,
            "id": 0,
            "creationTimeUnixTimeInMs": 0,
            "modificationTimeUnixTimeInMs": 0
        },
        {
            "connectorIdentifier": null,
            "paramName": "Proxy Password",
            "paramValue": "",
            "description": "The proxy password to authenticate with.",
            "type": 3,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": false,
            "isAdvanced": true,
            "id": 0,
            "creationTimeUnixTimeInMs": 0,
            "modificationTimeUnixTimeInMs": 0
        },
        {
            "connectorIdentifier": null,
            "paramName": "Get User Information",
            "paramValue": "false",
            "description": "If enabled, connector will additionally retrieve information about the users related to the incident.",
            "type": 0,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": false,
            "isAdvanced": true,
            "id": 0,
            "creationTimeUnixTimeInMs": 0,
            "modificationTimeUnixTimeInMs": 0
        }
    ],
    "allowList": [],
    "integrationVersion": 59.0,
    "isScriptConnector": true,
    "script": "import sys\nimport arrow\n\nfrom SiemplifyConnectors import CaseInfo, SiemplifyConnectorExecution\nfrom SiemplifyUtils import (\n    convert_string_to_datetime,\n    convert_datetime_to_unix_time,\n    output_handler,\n)\n\nfrom TIPCommon.extraction import extract_connector_param\nfrom TIPCommon.smp_time import (\n    siemplify_fetch_timestamp,\n    siemplify_save_timestamp,\n    validate_timestamp,\n)\nfrom TIPCommon.transformation import dict_to_flat\nfrom TIPCommon.utils import is_overflowed\n\n\nfrom constants import (\n    CONNECTOR_NAME,\n    PRODUCT_NAME,\n    VENDOR,\n    DEFAULT_DAYS_BACKWARDS,\n    MAX_INCIDENTS_PER_CYCLE,\n    CASE_RULE_GENERATOR,\n    NO_RESULTS,\n    SN_DEFAULT_DOMAIN,\n    DEFAULT_EVENT_NAME,\n    LINK_KEY,\n    PRIORITY_MAPPING,\n    LOW_PRIORITY,\n    EXCLUDE_INCIDENT_FIELDS\n)\nfrom exceptions import (\n    AssignmentGroupNotFoundError,\n    ServiceNowRecordNotFoundException,\n)\nfrom ServiceNowManager import ServiceNowManager, DEFAULT_TABLE\n\n\nclass ServiceNowConnector:\n\n    def __init__(\n        self,\n        connector_scope: SiemplifyConnectorExecution,\n        connector_name: str,\n        sn_manager: ServiceNowManager,\n        max_incidents_per_cycle: int,\n        server_time_zone: str,\n        whitelist: list[str],\n        whitelist_as_blacklist: bool,\n        is_test_run: bool = False,\n    ) -> None:\n        self.connector_scope = connector_scope\n        self.connector_scope.script_name = connector_name\n        self.logger = connector_scope.LOGGER\n        self.sn_manager = sn_manager\n        self.max_incidents_per_cycle = max_incidents_per_cycle\n        self.server_time_zone = server_time_zone\n        self.whitelist = self.get_whitelist_params(whitelist_pairs=whitelist)\n        self.whitelist_as_blacklist = whitelist_as_blacklist\n        self.is_test_run = is_test_run\n\n    def get_whitelist_params(self, whitelist_pairs):\n        \"\"\"\n        Extract whitelist fields\n        :param whitelist_pairs: {list} list of comma separated key values\n        :return: {dict} of all extracted fields\n        \"\"\"\n        result = {}\n        for whitelist in whitelist_pairs:\n            for field in whitelist.split(\",\"):\n                if \"=\" not in field:\n                    result[field] = \"\"\n                    continue\n                key, value = field.split(\"=\", 1)\n                result[key.strip()] = value.strip()\n\n        return result\n\n    def get_whitelist_queries(self):\n        \"\"\"\n        Get whitelist queries\n        :return: {list} of whitelist queries or None\n        \"\"\"\n        operator = \"!=\" if self.whitelist_as_blacklist else \"=\"\n\n        return self.prepare_whitelist_params_as_query(\n            whitelist_params=self.whitelist, operator=operator\n        )\n\n    def prepare_whitelist_params_as_query(self, whitelist_params, operator=\"=\"):\n        \"\"\"\n        Get whitelist params as query params.\n        :param whitelist_params {dict}\n        :param operator {str} '=' or '!=' ...\n        :return: {list} of query strings\n        \"\"\"\n        queries = []\n        for key, value in whitelist_params.items():\n            if key:\n                queries.append(f\"{key}{operator}{value}\")\n\n        return queries\n\n    def get_incidents(self, last_run, table_name, assignment_group):\n        \"\"\"\n        Get tickets since last success time.\n        :param last_run: {datetime} last run timestamp\n        :param table_name: {str} table name\n        :return: {list} of incidents {dict}\n\n        \"\"\"\n        sn_last_time_format = self.sn_manager.convert_datetime_to_sn_format(last_run)\n        incidents = []\n        sys_id = None\n        if assignment_group:\n            sys_id = self.get_sys_id_from_group_name(assignment_group)\n\n        try:\n            # Get tickets since last success time from specific table\n            incidents = self.sn_manager.get_incidents_by_filter(\n                creation_time=sn_last_time_format,\n                table_name=table_name,\n                custom_queries=self.get_whitelist_queries(),\n                sys_id=sys_id,\n            )\n            # Sort tickets so the first will be the oldest ticket that was updated\n            incidents = sorted(incidents, key=lambda incident: incident.sys_created_on)\n\n            # Tickets limit per cycle - Default - The 10 oldest incidents (Ticket are sorted by times)\n            incidents = incidents[: self.max_incidents_per_cycle]\n\n            for incident in incidents:\n                for key, value in incident.raw_data.items():\n                    if isinstance(value, dict) and LINK_KEY in value:\n                        link_url = value.get(LINK_KEY)\n                        if any(field in key or field in link_url\n                               for field in EXCLUDE_INCIDENT_FIELDS):\n                            continue\n\n                        try:\n                            incident.raw_data[key][\"context\"] = (\n                                self.sn_manager.get_additional_context_for_field(\n                                    link=value.get(LINK_KEY)\n                                )\n                            )\n                        except Exception as e:\n                            self.logger.error(\n                                f\"Failed to fetch more context for incident {incident.number} \"\n                                f'field \"{key}\". Error: {e}.'\n                            )\n\n        except Exception as e:\n            if NO_RESULTS not in str(e):\n                self.logger.error(\"Failed to fetch incidents\")\n                self.logger.exception(e)\n\n        self.logger.info(\n            f\"Found {len(incidents)} incidents since {str(sn_last_time_format)}.\"\n        )\n\n        return incidents\n\n    def get_sys_id_from_group_name(self, assignment_group: str) -> str:\n        \"\"\"Get the sys_id of an assignment group, using cache if available.\n\n        Args:\n            assignment_group (str): The name of the assignment group.\n\n        Raises:\n            AssignmentGroupNotFoundException: If the assignment group is not found.\n\n        Returns:\n            str: The sys_id of the assignment group.\n        \"\"\"\n        sys_id = self.connector_scope.get_connector_context_property(\n            identifier=self.connector_scope.context.connector_info.identifier,\n            property_key=assignment_group,\n            )\n        if sys_id is None:\n            try:\n                sys_id = self.sn_manager.get_sys_id_from_group_name(assignment_group)\n                if not self.is_test_run:\n                    self.connector_scope.set_connector_context_property(\n                        identifier=(\n                            self.connector_scope.context.connector_info.identifier\n                        ),\n                        property_key=assignment_group,\n                        property_value=sys_id,\n                    )\n            except ServiceNowRecordNotFoundException as e:\n                raise AssignmentGroupNotFoundError(\n                    f\"Error executing {CONNECTOR_NAME}. Reason: \\\"{assignment_group}\\\" \"\n                    \"Assignment Group wasn't found in ServiceNow. Please check the \"\n                    \"spelling.\"\n                ) from e\n\n        return sys_id\n\n    def update_incident_user_info(self, incident):\n        \"\"\"\n        Update incident user info\n        :param incident: {Incident} Incident instance\n        \"\"\"\n        if incident.opener_id and incident.caller_id:\n            user_info = self.sn_manager.get_user_info(\n                incident.opener_id, incident.caller_id\n            )\n            user_info = user_info[0] if user_info else None\n            if user_info:\n                incident.update_incident_with_user_info(user_info)\n\n    def is_valid_incident_time(self, last_run_time, incident_dict):\n        \"\"\"\n        Compare incident time to connector last run time to make sure incidents are not taken more than once.\n        Base on the ServiceNow Api, incident fetch without time zone\n        :param last_run_time: {datetime} last execution time from file\n        :param incident_dict: {Incident object}\n        :return: {Boolean}\n        \"\"\"\n        # compare full dates\n        incident_time = convert_string_to_datetime(\n            incident_dict.get(\"opened_at\"), timezone_str=self.server_time_zone\n        )\n        # Checking if incident is already taken, if yes - incident is not valid.\n        if incident_time <= last_run_time:\n            return False\n        return True\n\n    def create_event(self, incident, event_name):\n        \"\"\"\n        Create events from incident data\n        :param incident: {dict} All incident data\n        :param event_name: {string} name of the event\n        :return: event {dict} one event from the incident data\n        \"\"\"\n        event_details = dict_to_flat(incident)\n        event_details[\"event_name\"] = event_name\n        try:\n            # Incident date is in UTC time, save time in unix (milliseconds).\n            event_time = (\n                convert_datetime_to_unix_time(\n                    convert_string_to_datetime(\n                        incident.get(\"sys_created_on\"),\n                        timezone_str=self.server_time_zone,\n                    )\n                )\n                if incident.get(\"sys_created_on\")\n                else 1\n            )\n        except Exception as e:\n            self.logger.error(f\"Failed to get incident creation time. {e}\")\n            event_time = 1\n\n        event_details[\"StartTime\"] = event_details[\"EndTime\"] = event_time\n        return event_details\n\n    @staticmethod\n    def map_priority(sn_priority):\n        \"\"\"\n        Mapping ServiceNow priority to siemplify priority\n        :param sn_priority: {string} '1, 2 or 3' (1=high, 2=medium, 3=low)\n        :return: {int} (40=low, 60=medium, 80=high)\n        \"\"\"\n        return PRIORITY_MAPPING.get(sn_priority, LOW_PRIORITY)\n\n    def create_case_info(\n        self, incident, event, connector_environment, rule_generator_field\n    ):\n        \"\"\"\n        Get alerts from Incident\n        :param incident: {dict} An incident data\n        :param event: {dict} one event from the incident data\n        :param connector_environment: {string} Connector default environment\n        :param rule_generator_field: {string} Rule generator field name\n        :return: {CaseInfo} case\n        \"\"\"\n        # Validate incident number exists\n        case_info = CaseInfo()\n        try:\n            incident_number = incident[\"number\"]\n            case_info.name = incident[\"number\"]\n        except Exception as e:\n            incident_number = incident[\"sys_id\"]\n            case_info.name = incident_number\n            self.logger.error(\n                f\"Found incident, cannot get its number. Get its SysID{str(e)}\"\n            )\n            self.logger.exception(e)\n\n        self.logger.info(f\"Creating Case for incident {incident_number}\")\n        # Create the CaseInfo\n        try:\n            if rule_generator_field:\n                case_info.rule_generator = incident.get(\n                    rule_generator_field, CASE_RULE_GENERATOR\n                )\n            else:\n                case_info.rule_generator = CASE_RULE_GENERATOR\n\n            try:\n                # Incident date is in UTC time, save time in unix (milliseconds).\n                case_info.start_time = (\n                    convert_datetime_to_unix_time(\n                        convert_string_to_datetime(\n                            incident.get(\"sys_created_on\"),\n                            timezone_str=self.server_time_zone,\n                        )\n                    )\n                    if incident.get(\"sys_created_on\")\n                    else 1\n                )\n            except Exception as e:\n                self.logger.error(f\"Failed to get incident creation time. {e}\")\n                case_info.start_time = 1\n\n            case_info.end_time = case_info.start_time\n\n            case_info.identifier = incident_number\n            case_info.ticket_id = case_info.identifier\n            # Priority mapped from service now values to siemplify values\n            case_info.priority = self.map_priority(incident.get(\"urgency\"))\n            case_info.device_vendor = VENDOR\n            case_info.device_product = PRODUCT_NAME\n            case_info.display_id = case_info.identifier\n\n            # Domain is set by the caller. Siemplify Environment = SN Domain\n            try:\n                domain_id = incident[\"sys_domain\"][\"value\"]\n                if domain_id != SN_DEFAULT_DOMAIN:\n                    case_info.environment = self.sn_manager.get_full_domain_name_by_id(\n                        domain_id\n                    )\n                else:\n                    case_info.environment = connector_environment\n            except Exception as e:\n                self.logger.error(\"Failed to get incident domain.\")\n                self.logger.exception(f\"Error: {e}\")\n                case_info.environment = connector_environment\n\n            case_info.events = [event]\n\n        except KeyError as e:\n            raise KeyError(f\"Mandatory key is missing: {str(e)}. Skipping Incident.\")\n\n        return case_info\n\n\n@output_handler\ndef main(is_test=False):\n    connector_scope = SiemplifyConnectorExecution()\n    output_variables = {}\n    log_items = []\n\n    connector_scope.LOGGER.info(\"======= Starting ServiceNow Connector. =======\")\n\n    try:\n\n        default_incident_table = extract_connector_param(\n            connector_scope,\n            param_name=\"Incident Table\",\n            print_value=True,\n            default_value=DEFAULT_TABLE,\n        )\n\n        # Configurations.\n        api_root = extract_connector_param(\n            connector_scope, param_name=\"Api Root\", print_value=True\n        )\n        username = extract_connector_param(\n            connector_scope, param_name=\"Username\", print_value=False\n        )\n        password = extract_connector_param(\n            connector_scope, param_name=\"Password\", print_value=False\n        )\n        verify_ssl = extract_connector_param(\n            connector_scope,\n            param_name=\"Verify SSL\",\n            default_value=True,\n            input_type=bool,\n        )\n        client_id = extract_connector_param(\n            connector_scope, param_name=\"Client ID\", print_value=False\n        )\n        client_secret = extract_connector_param(\n            connector_scope, param_name=\"Client Secret\", print_value=False\n        )\n        refresh_token = extract_connector_param(\n            connector_scope, param_name=\"Refresh Token\", print_value=False\n        )\n        assignment_group = extract_connector_param(\n            connector_scope,\n            param_name=\"Assignment Group\",\n            print_value=True,\n        )\n        use_oauth = extract_connector_param(\n            connector_scope,\n            param_name=\"Use Oauth Authentication\",\n            default_value=False,\n            input_type=bool,\n        )\n\n        service_now_manager = ServiceNowManager(\n            api_root=api_root,\n            username=username,\n            password=password,\n            default_incident_table=default_incident_table,\n            verify_ssl=verify_ssl,\n            siemplify_logger=connector_scope.LOGGER,\n            client_id=client_id,\n            client_secret=client_secret,\n            refresh_token=refresh_token,\n            use_oauth=use_oauth,\n        )\n\n        days_backwards = extract_connector_param(\n            connector_scope,\n            param_name=\"Days Backwards\",\n            print_value=True,\n            input_type=int,\n            default_value=DEFAULT_DAYS_BACKWARDS,\n        )\n        max_incidents_per_cycle = extract_connector_param(\n            connector_scope,\n            param_name=\"Max Incidents Per Cycle\",\n            print_value=True,\n            input_type=int,\n            default_value=MAX_INCIDENTS_PER_CYCLE,\n        )\n        server_time_zone = extract_connector_param(\n            connector_scope,\n            param_name=\"Server Time Zone\",\n            print_value=True,\n            default_value=\"UTC\",\n        )\n        rule_generator_field = extract_connector_param(\n            connector_scope, param_name=\"Rule Generator\", print_value=True\n        )\n        table_name = extract_connector_param(\n            connector_scope, param_name=\"Table Name\", print_value=True\n        )\n        event_name = extract_connector_param(\n            connector_scope,\n            param_name=\"Event Name\",\n            print_value=True,\n            default_value=DEFAULT_EVENT_NAME,\n        )\n        get_user_info = extract_connector_param(\n            connector_scope,\n            param_name=\"Get User Information\",\n            input_type=bool,\n            print_value=True,\n        )\n        whitelist_as_blacklist = extract_connector_param(\n            connector_scope,\n            param_name=\"Use whitelist as a blacklist\",\n            input_type=bool,\n            print_value=True,\n        )\n        environments_whitelist = extract_connector_param(\n            connector_scope, param_name=\"Environments Whitelist\", print_value=True\n        )\n        if environments_whitelist:\n            environments_whitelist = environments_whitelist.split(\",\")\n        else:\n            environments_whitelist = []\n\n        connector_environment = connector_scope.context.connector_info.environment\n\n        servicenow_connector = ServiceNowConnector(\n            connector_scope,\n            CONNECTOR_NAME,\n            service_now_manager,\n            max_incidents_per_cycle,\n            server_time_zone,\n            connector_scope.whitelist,\n            whitelist_as_blacklist,\n            is_test,\n        )\n\n        # Fix first time run\n        last_run_time = siemplify_fetch_timestamp(connector_scope, datetime_format=True)\n        last_calculated_run_time = validate_timestamp(\n            last_run_time, days_backwards, offset_is_in_days=True\n        )\n        # Convert timezone\n        aware_time = arrow.get(last_calculated_run_time).to(server_time_zone).datetime\n        connector_scope.LOGGER.info(\n            f\"Calculating connector last run time. Last run time is: {last_calculated_run_time}\"\n        )\n\n        # Get alerts\n        connector_scope.LOGGER.info(\"Collecting Incidents.\")\n        incidents = servicenow_connector.get_incidents(\n            last_run=aware_time,\n            table_name=table_name,\n            assignment_group=assignment_group,\n        )\n\n        # Test on one incident only\n        if is_test:\n            incidents = incidents[:1]\n\n        all_cases = []\n        cases_to_ingest = []\n        for incident in incidents:\n            try:\n                if get_user_info:\n                    servicenow_connector.update_incident_user_info(incident)\n\n                # Create security event\n                event = servicenow_connector.create_event(\n                    incident.to_json(), event_name\n                )\n\n                # Create case info\n                case = servicenow_connector.create_case_info(\n                    incident.to_json(),\n                    event,\n                    connector_environment,\n                    rule_generator_field,\n                )\n\n                is_overflow = is_overflowed(connector_scope, case, is_test)\n                if is_overflow:\n                    # Skipping this alert (and dot ingest it to siemplify)\n                    connector_scope.LOGGER.info(\n                        f\"{str(case.rule_generator)}-{str(case.ticket_id)}-{case.environment}-{str(case.device_product)} found as overflow alert. Skipping\"\n                    )\n\n                else:\n                    # Validate that the environment is in the whitelist\n                    if (\n                        case.environment\n                        and (case.environment not in environments_whitelist)\n                        and environments_whitelist\n                    ):\n                        connector_scope.LOGGER.warn(\n                            f\"Environment is not in whitelist - {str(case.environment)}\"\n                        )\n                    else:\n                        # Ingest the case to siemplify\n                        cases_to_ingest.append(case)\n                all_cases.append(case)\n\n            except Exception as e:\n                connector_scope.LOGGER.error(\"Failed to create CaseInfo\")\n                connector_scope.LOGGER.error(f\"Error Message: {str(e)}\")\n                connector_scope.LOGGER.exception(e)\n                if is_test:\n                    raise\n\n        connector_scope.LOGGER.info(\"Completed processing incidents.\")\n        connector_scope.LOGGER.info(\n            \"Ingest case to Siemplify only if the domain incident is in the whitelist \"\n            \"or if the Incident is in the Default domain.\"\n        )\n\n        # Get last successful execution time.\n        if all_cases:\n            # Sort the not_overflow_cases by the end time of each case.\n            all_cases = sorted(all_cases, key=lambda case: case.end_time)\n            # Last execution time is set to the newest message time\n            new_last_run_time = all_cases[-1].end_time\n        else:\n            # last_calculated_run_time is datetime object. Convert it to milliseconds timestamp.\n            new_last_run_time = convert_datetime_to_unix_time(aware_time)\n\n        connector_scope.LOGGER.info(f\"Create {len(cases_to_ingest)} cases.\")\n        if is_test:\n            connector_scope.LOGGER.info(\n                \"======= ServiceNow Connector Test Finish. =======\"\n            )\n        else:\n            siemplify_save_timestamp(connector_scope, new_timestamp=new_last_run_time)\n\n            connector_scope.LOGGER.info(\"======= ServiceNow Connector Finish. =======\")\n\n        connector_scope.return_package(cases_to_ingest, output_variables, log_items)\n\n    except Exception as e:\n        if not is_test:\n            connector_scope.LOGGER.error(str(e))\n            connector_scope.LOGGER.exception(e)\n        else:\n            connector_scope.LOGGER.exception(e)\n            raise\n\n\nif __name__ == \"__main__\":\n    if len(sys.argv) < 2 or sys.argv[1] == \"True\":\n        print(\"Main execution started\")\n        main()\n    else:\n        print(\"Test execution started\")\n        main(is_test=True)\n",
    "documentationLink": "https://cloud.google.com/chronicle/docs/soar/marketplace-integrations/servicenow#servicenow_connector",
    "deviceProductField": "Product Name",
    "eventNameField": "sys_class_name",
    "connectorStatus": null,
    "isNew": false,
    "agentIdentifier": "363fab3c-4764-4879-b0b5-6958e3f32e11"
}